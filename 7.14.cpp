#include <stdio.h>
// 操作符详解 2021.7.14
//分类:
//算术、移位、位、赋值、单目、关系、逻辑、条件、逗号表达式、下标引用、函数调用和结构成员

//算术：+-*/% 
//%取模：两边必须都是整数
 
//移位操作符： >> 右移二进制位 << 左移二进制位
//右移: (有/2效果)
//1.算术右移
//右丢弃,左补原符号位 
//2.逻辑右移 
//右丢弃,左补0 
//int main()
//{
//	int a = -1;
//	//整数的二进制表示有:原码、反码、补码，在内存中均为补码 
//	// 正数的三码合一都为原码，即其二进制表示
//	// 负数：反码为原码除符号位其余按位取反，补码是反码+1
//	// -1原码:10000000 00000000 00000000 00000001 
//	// 反码：11111111 11111111 11111111 11111110
//	// 补码： 11111111 11111111 11111111 11111111 
//	int b = a>>1;
//	printf("%d",b); 
//	return 0;
//}

//左移：左边丢弃、右边补0 左移有*2效果
//int main()
//{
//	int a = -1;
//	int b = a<<1;
//	printf("%d\n",b); // -2
//	return 0;
// } 

//对于移位运算符不能移动负数位！不能作用于浮点数 

// &按位与 |按位或 ^按位异或 (二进制位)

//统计num的补码中有几个1
//int main()
//{
//	int num = 0;
//	int count = 0;
//	scanf("%d",&num);
//	for (int i=0;i<32;i++)
//	{
//		if (num>>i&1 == 1) count++;
//	}
//	printf("%d\n",count);
//	return 0;
// } 
//更好的方法!?


//单目操作符:
// !:逻辑反  -:负号  &:取地址操作符  *:解引用操作符  
// ~:二进制位按位取反  sizeof:计算变量所占空间的大小,单位是字节

//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d\n",sizeof(s = a+5)); // sizeof里的表达式不真正参与运算,不真正赋值,而a+5要被缩减为短整型,必须返回2个字节 
//	printf("%d\n",s); 
//	// 2,0
//}

//前置++:先++,再用a ; 后置++:先用a后++ 

// (类型) 强制类型转换

//int main()
//{	// &&碰到0则停止, ||碰到1则停止 
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n",a,b,c,d);
//	// 2 3 3 5
//	printf("\n");
//	a = 1, b = 2, c = 3, d = 4;
//	i = a++ || ++b || d++;
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n",a,b,c,d);
//	// 2 2 3 4
//	return 0;
//}


//条件操作符
//int main()
//{
//	int a = 0;
//	int b = 0;
////	if (a>5) b = 3;
////	else b = -3; 与下面的三目操作符等价 
//	b = (a>5 ? 3:-3);
//	printf("%d\n",b);
//	return 0;
// } 
 
//int main() // 求两个数的最大值 
//{
//	int a = 10;
//	int b = 20;
//	int max = 0;
//	max = (a>b ? a:b);
//	printf("%d\n",max);
//	return 0;
//}
 
// 逗号表达式:从左到右进行,整个表达式的结果是最后一个表达式的结果
//改写以下代码:
//a = getval();
//countval(a);
//while (a>0)
//{
//	// 业务处理
//	a = getval();
//	countval(a); 
// } 
//-->
//while (a = getval(), countval(a), a>0)



// 点操作符:访问结构体成员 
//创建一个结构体类型- struct Stu
//struct Stu
//{ // 成员变量 
//	char name[20];
//	int age;
//	char id[20];
// };
//int main()
//{
//	struct Stu s1 = {"Sheldon", 20, "23232323"
//	};
//	struct Stu s2 = {"Mary", 198, "000000"
//	};
//	printf("%s\n",s2.name);
//	printf("%d\n",s1.age);
//	
//	
//	struct Stu* ps1 = &s1;
//	printf("%d\n",ps1->age); // 结构体指针的指向操作符 
//	printf("%s\n",ps1->id); 
// } 


//隐式类型转换:
//算术运算(+-*/ 比较 +c -c都算运算 !c不是运算)总是至少以int型精度进行(缺省),为了获得此精度,表达式中字符和短整型
//操作数在使用前被转换成普通整型,这种转换为整型提升.
//整型提升:用符号位补齐4个字节 unsigned int直接补0 

//算术转换:
//占空间小的转换成大的和大的运算 

//有问题的表达式:
// a*b + c*d + e*f
// 优先级并不能保证第三个*比第一个+早执行
//有可能是
//a*b
//c*d
//a*b+c*d
//e*f
//a*b+c*d+e*f
//也有可能是先三个乘法再两个加法 
// ++和--的优先值高于+ 
// c + --c; 
// --在+之前运算,但无法确定左边的c是在--后确定还是--前确定,有歧义
// 写表达式时应该有唯一的运算路径 








 








 
