// 2027.7.17
#include <stdio.h>
// 数据的存储

//正数:原反补相同
//负数:原码直接写,反码再取反,补码再加一
//数据存补码,补码可以把减法转换成加法,补码可以将符号位和数值域统一处理,此外,补码原码相互转换,运算过程相同,不需要额外电路 
//数字在地址里反着存 
//
//大端小端:
//大端(字节序)存储模式:数据低位保存在高地址
//小端(字节序)存储模式:低位低地址
//0x 11 22 33 44--44 33 22 11 // 44低位,在左边(低地址),44是一个字节
//判断字节序:
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	if (check_sys) printf("小端\n");
//	else printf("大端\n");
//	return 0;
//}

//int main()
//{
//	char a=-1; // 把-1的补码切成一个字节(留右边的) 
//	signed char b= -1;
//	unsigned char c = -1;
//	// 打印%d,需要整型提升,按符号位向前补,有符号的负数前面补1补到32位,无符号直接补0 
//	printf("a=%d,b=%d,c=%d\n",a,b,c); // -1 -1 255
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//00000000000000000000000010000000 原码
//	//11111111111111111111111101111111  反码 
//	//11111111111111111111111110000000 补码
//	// 1000000
//	// 11111111111111111111111110000000 整型提升(按无符号数打印) 
//	printf("%u\n",a); // %u--打印十进制的无符号数字 
//	return 0;
//}

//有符号数:10000000(补码)直接被翻译成-128,不借位
//有符号的char的范围:-128~127
//无符号:0~255 
#include <string.h>
// int main()
// { // char只能容纳-128~127的整数,-128-1=127
//     char a[1000];
//     int i;
//     for (i=0;i<1000;i++)
//     {
//         a[i] = -1-i;
//     }
//     printf("%d\n",strlen(a)); // 找\0,\0的axcii码是0,所以找数字0也行
//     return 0; // 255
        //  -1,-2,...,-128,127,126,...,3,2,1,0
// } 

// 各个类型最大最小值的查询:limits.h

//内存中浮点数的表示:
// 所有浮点数都可以写成:
// (-1)^S * M * 2^E
// 其中S为0或1,1<=M<2,E为整数,不同类型浮点数M和E的取值范围不同
// 存储时省略M第一位的1,存储E时需要加127/1023并转化成二进制序列,按照:
// S E(binery) M(1 is omitted)
// 其中S占1 bit, E占1byte,剩余的字节数由M添加0补齐
// 如:
// 5.5 = (-1)^0 * 1.011 * 2^2
// = 0 10000001 011(后面20个0)

// 当E全为0时,还原时不再补1,直接写0.xxx,指数E为-126,
// 如 0 00000000 011(20个0)
//  = 0.011 * 2^(-126)
// 以此表示+-0或接近+-0的很小的数字

// 当E全为1时,如果有效数字M全为0,表示正负无穷大
//%f 只打印小数点之后的6个bit位